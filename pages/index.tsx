import { useEffect, useState } from 'react';
import type { NextPage } from 'next';
import Head from 'next/head';
import Image from 'next/image';

import Navbar from '../components/Navbar';
import ChatBox from '../components/ChatBox';
import Leaderboard from '../components/Leaderboard';
import Timer from '../components/Timer';
import VoteControls from '../components/VoteControls';
import NewCategoryPopup from '../components/NewCategoryPopup';
import VoteItem from '../components/VoteItem';

import { tmiGetCategories, messages, tmiAddCategory } from '../utils/tmi'; 
import toggleDimmer from '../utils/toggleDimmer';

interface ChatData{
  messages: any[];
}

const Home: NextPage = () => {
  const [chatData, setChatData] = useState<ChatData | undefined>(undefined);
  const [votingCategories, setVotingCategories] = useState<any>([]);
  const [leaderboard, setLeaderboard] = useState<any>([]);
  const [isTimerRunning, setTimer] = useState<boolean>(false);
  const [isCreatingNew, setIsCreatingNew] = useState<boolean>(false);
  const [slotIndex, setSlotIndex] = useState<number | undefined>(undefined);
  const categoryOptions = [2, 4, 6, 8];

  const [categoryCount, setCategoryCount] = useState<any>(categoryOptions[0]);

  const handleFilter = (categoryCount: string) =>{
    setCategoryCount(+categoryCount);
  }

  useEffect(()=>{
    setVotingCategories(tmiGetCategories());
  },[])


  useEffect(()=>{
    let timerFunc = setInterval(() => {
      setChatData({
        messages: messages
      });
    }, 1000);
    return () => clearInterval(timerFunc)
  });

  useEffect(()=>{
    const isOverflowing = votingCategories.length > categoryCount;
    if(isOverflowing){
      handleOverflow();
    }else{
      setVotingCategories([...votingCategories, ...new Array(categoryCount - votingCategories.length).map(()=>undefined)]);
    }
  }, [categoryCount])

  const handleOverflow = () =>{
    const definedCategories = votingCategories.filter((value: any)=>value!=undefined);
    setVotingCategories(
      definedCategories.slice(0, categoryCount)
    );
  }

  const addVotingCategoryAtIndex = (category: { name: string, color: string }, slotIndex: number, isEditing: boolean) =>{
    const isFull = votingCategories.indexOf(undefined) == -1;
    if(!isFull || isEditing){
      setVotingCategories([
        ...votingCategories.slice(0, slotIndex), 
        category, 
        ...votingCategories.slice(slotIndex+1)
      ]);
      tmiAddCategory(category);
    }else{
      throw('max categories reached');
    }
  }

  const pushVotingCategory = (category: { name: string, color: string }) =>{
    const isFull = votingCategories.indexOf(undefined) == -1;
    const emptyIndex = votingCategories.indexOf(undefined);
    if(isFull && categoryOptions.length != categoryOptions.indexOf(categoryCount)){
      setVotingCategories([
        ...votingCategories,
        category,
        undefined
      ]);
      setCategoryCount(categoryOptions[categoryOptions.indexOf(categoryCount)+1])
    }else if(categoryOptions.length != categoryOptions.indexOf(categoryCount)){
      setVotingCategories([
        ...votingCategories.slice(0, emptyIndex),
        category,
        ...votingCategories.slice(emptyIndex+1)
      ]);
    }else{
      throw('max categories reached');
    }
    tmiAddCategory(category);
  }

  const removeCategory = (index: number) =>{
    setVotingCategories([
      ...votingCategories.slice(0, index),
      undefined,
      ...votingCategories.slice(index+1)
    ])
  }

  const openPopup = (slotIndex: number) =>{
    setSlotIndex(slotIndex);
    setIsCreatingNew(true);
  }

  return (
    <div className='index'>
      <Head>
        <title>Stream Vote</title>
        <meta name="description" content="Generated by create next app" />
        <meta name="viewport" content="width=device-width, maximum-scale=1, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <NewCategoryPopup 
        isCreatingNew={isCreatingNew}
        setIsCreatingNew={setIsCreatingNew}
        votingCategories={votingCategories}
        addVotingCategoryAtIndex={addVotingCategoryAtIndex}
        pushVotingCategory={pushVotingCategory}
        slotIndex={slotIndex}
        setSlotIndex={setSlotIndex}
      />
      <div className="main">
        <VoteControls 
          addVotingCategory={addVotingCategoryAtIndex}
          setIsCreatingNew={setIsCreatingNew}
          isCreatingNew={isCreatingNew}
          categoryCount={categoryCount}
          setCategoryCount={setCategoryCount}
          categoryOptions={categoryOptions}
          handleFilter={handleFilter}
        />
        <Timer
          isRunning={isTimerRunning}
          setTimer={setTimer}
        />
        <Leaderboard 
          leaderboard={votingCategories.slice(0, 3)}
        />
        <div className='main__left main__vote-container'>
          {
            Array.from(Array(Math.ceil(categoryCount/2))).map((value: any, index: number)=>{
              const location = index+index+1;
              const category = votingCategories[location];
              return (
                <VoteItem 
                  openPopup={openPopup}
                  categoryData={category}
                  index={location}
                  categoryCount={categoryCount}
                  removeCategory={removeCategory}
                />
              );
            })
          }
        </div>
        <div className="main__center">
          <ChatBox 
            chatData={chatData}
          /> 
        </div>
        <div className='main__right main__vote-container'>
          {
            Array.from(Array(Math.floor(categoryCount/2))).map((value: any, index: number)=>{
              const location = index*2;
              const category = votingCategories[location];
              return(
                <VoteItem 
                  openPopup={openPopup}
                  categoryData={category}
                  index={location}
                  categoryCount={categoryCount}
                  removeCategory={removeCategory}
                />
              )
            })
          }
        </div>
      </div>
    </div>
  )
}

export default Home;
